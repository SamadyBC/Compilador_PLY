# C-Like Language Lexical and Syntactic Analyzer

This repository contains a lexical and syntactic analyzer for a subset of the C programming language. It is implemented in Python using the `ply` (Python Lex-Yacc) library.

The analyzer can:

- Tokenize input code written in the C-like language.
- Parse the token stream according to a defined grammar to identify valid program structures.

## Repository Structure

The repository contains the following key files:

- **`sintatic_analyser.py`**: This is the main Python script that defines the lexer (for tokenizing the input) and the parser (for analyzing the syntax) using the `ply` library. It includes the grammar rules and actions for the C-like language.
- **`parsetab.py`**: This file is automatically generated by `ply` when the parser is first created. It stores the LALR parsing tables, which are essential for the parsing process. It's generally not meant to be edited manually.
- **`input*.txt`**: These are sample input files containing C-like code that can be used to test the analyzer. For example, `input1.txt`, `input2.txt`, etc.
- **`parselog.txt`**: This file logs debugging information from the parsing process, generated by `yacc` (part of `ply`). It's useful for tracing how the parser handles the input.
- **`parser.out`**: This file is also generated by `yacc` and contains a summary of the grammar and parsing states.

## How to Run

1.  **Prerequisites**: Ensure you have Python installed. You'll also need the `ply` library. If you don't have it, you can install it using pip:
    ```bash
    pip install ply
    ```
2.  **Prepare Input**: The `sintatic_analyser.py` script reads input from a file named `input8.txt` by default. You can modify the script to read from a different file or create/edit `input8.txt` with the C-like code you want to analyze.
3.  **Run the Analyzer**: Execute the script from your terminal:
    ```bash
    python sintatic_analyser.py
    ```
4.  **Output**:
    - The script will print the recognized tokens to the console.
    - It will also print messages indicating the recognized grammatical structures (e.g., "Reconheci INICIAL", "Declarada vari√°vel 'x' do tipo 'int'").
    - Parsing logs, including any syntax errors, will be written to `parselog.txt`.
    - The symbol table at the end of a successful parse will be printed to the console.

## Future Improvements

This analyzer provides a basic framework. Here are some potential areas for future development:

- **Semantic Analysis**: Implement checks for semantic correctness, such as type compatibility in expressions, variable declaration before use (though some basic checks are present), and scope resolution.
- **Intermediate Code Generation**: Extend the parser to generate an intermediate representation (e.g., three-address code) of the input program.
- **Target Code Generation**: Further extend to compile the intermediate code into machine code for a specific architecture or into another high-level language.
- **Enhanced Error Reporting**: Improve error messages to be more specific and provide better guidance on how to fix syntax or semantic errors.
- **Expanded Grammar**: Add support for more C language features, such as:
  - Pointers
  - Structs and Unions
  - Functions with parameters and return values (beyond the basic `main` structure)
  - More complex expressions and statements
  - Preprocessor directives
- **More Comprehensive Test Suite**: Develop a wider range of test cases, including edge cases and invalid inputs, to ensure robustness.
- **Symbol Table Enhancements**: Improve the symbol table to handle scopes more effectively and store more information about identifiers.

## TO DO & Issues:

- Fix the verification of redeclaration to the new declaration structures. (tipos ID EQUALS ID SEMICOLON and tipos ID EQUALS operacao_aritmetica SEMICOLON) -
- In the case of: tipos ID EQUALS ID SEMICOLON. Make sure that the second ID was declared before being used. - verificar_variavel_usada(arg,arg)
- Arithmetic operations are not returning the result of the operation to the table of data. It is important and must be fixed.
- Implement `return 0` to make the code more similar to actual C code.
- Standardize the aux function to have the same return pattern.
- Fix the way a number is being interpreted. In my case the 2 is being read as a string.
- Refactor the code and create a single function responsible for raising exceptions
